# **FlowBeat 在线音乐推荐系统 \- 需求规格说明书 (SRS)**

## **1\. 项目上下文 (Project Context)**

### **1.1 项目背景**

FlowBeat 是一个基于 B/S (Browser/Server) 架构的现代化在线流媒体音乐平台。本项目旨在解决传统音乐库“信息过载”的问题，通过引入个性化推荐算法，帮助用户在海量曲库中高效发现符合其审美偏好的音乐内容。

### **1.2 核心目标**

* **流媒体服务**：提供高可用、低延迟的音乐在线播放体验。  
* **个性化推荐**：利用协同过滤算法挖掘用户潜在兴趣。  
* **内容管理**：构建结构化的音乐元数据管理系统。

### **1.3 领域边界 (Domain Boundaries)**

根据领域驱动设计 (DDD) 理念，系统划分为以下核心子域：

* **身份认证子域 (Identity Subdomain)**：处理用户注册、登录及 RBAC 权限控制。  
* **内容分发子域 (Content Distribution Subdomain)**：负责音频文件的存储 (MinIO) 与流式传输。  
* **元数据子域 (Metadata Subdomain)**：管理艺术家、专辑、音乐及其关联关系的结构化数据。  
* **推荐子域 (Recommendation Subdomain)**：负责用户行为数据的采集、相似度矩阵计算及推荐列表生成。

## **2\. 技术栈约束 (Technology Stack Constraints)**

本项目强制采用以下技术选型，任何开发活动必须严格遵守此约束，以确保系统架构的一致性和学术规范性。

### **2.1 后端架构 (Backend)**

* **开发语言**: Python 3.12+  
* **Web 框架**: FastAPI (遵循 RESTful API 规范，全异步 Async/Await 模式)  
* **ORM 框架**: SQLAlchemy 2.0 (Async Mode)  
* **数据验证**: Pydantic v2  
* **异步任务队列**: Celery \+ Redis (用于处理离线推荐计算)  
* **科学计算与算法**: NumPy, Scikit-learn, Surprise (用于实现协同过滤)

### **2.2 前端架构 (Frontend)**

* **核心框架**: Vue 3 (Composition API)  
* **编程语言**: TypeScript (强类型约束)  
* **构建工具**: Vite  
* **UI 组件库**: Naive UI (支持深色模式)  
* **状态管理**: Pinia  
* **路由管理**: Vue Router 4  
* **HTTP 客户端**: Axios (统一拦截器处理 Token)

### **2.3 基础设施 (Infrastructure)**

* **关系型数据库**: PostgreSQL 16 (存储业务元数据)  
* **对象存储**: MinIO (存储音频文件、封面图片等非结构化数据)  
* **缓存/消息代理**: Redis 7  
* **Web 服务器**: Nginx (反向代理、静态资源托管)  
* **容器化**: Docker & Docker Compose

## **3\. 核心算法策略 (Algorithm Strategy)**

本项目采用 **基于物品的协同过滤 (Item-based Collaborative Filtering)** 作为核心推荐策略。

### **3.1 算法原理**

基于假设：喜欢物品 A 的用户，倾向于喜欢与 A 相似的物品 B。在音乐场景中，物品（音乐）的特征相对稳定，而用户兴趣多变，因此 Item-based CF 相比 User-based CF 具有更高的计算稳定性和可解释性。

### **3.2 实施步骤**

1. 隐式反馈采集 (Implicit Feedback Collection)：  
   系统自动记录用户的交互行为，并转化为评分权重：  
   * **完整播放**: 权重 1.0  
   * **收藏/红心**: 权重 5.0  
   * **跳过**: 权重 0  
2. 相似度计算 (Similarity Calculation)：  
   通过 Celery 定时任务，利用余弦相似度 (Cosine Similarity) 计算物品之间的相似性矩阵。  
   $$
    Similarity(i, j) = \cos(\vec{i}, \vec{j}) = \frac{\vec{i} \cdot \vec{j}}{\| \vec{i} \| \| \vec{j} \|}
   $$
   其中 $\vec{i}$ 和 $\vec{j}$ 分别代表物品 $i$ 和物品 $j$ 在用户空间中的评分向量。  
3. Top-K 推荐 (Recommendation Generation)：  
   根据用户历史高分记录，检索相似度最高的 K 个物品，过滤掉已听过的音乐后生成推荐列表。

## **4\. 核心数据模型 (Core Data Schema)**

数据库设计需严格遵循第三范式 (3NF)，主要实体关系如下：

### **4.1 实体关系图 (Textual ERD)**

Artist (1) \----\< (N) Album  
Album (1)  \----\< (N) Music  
User (1)   \----\< (N) Interaction  
Interaction (N) \>---- (1) Music

### **4.2 实体定义**

1. **User (用户)**  
   * id: 主键, UUID 或 BigInt.  
   * username: 用户名, 唯一索引.  
   * password\_hash: 加密后的密码.  
   * role: 枚举类型 (ADMIN, USER), 用于 RBAC 控制.  
2. **Artist (艺术家)**  
   * id: 主键.  
   * name: 艺术家姓名.  
   * bio: 简介 (Text).  
   * avatar\_url: 头像图片地址 (MinIO).  
3. **Album (专辑)**  
   * id: 主键.  
   * title: 专辑标题.  
   * artist\_id: 外键 \-\> Artist.id.  
   * release\_date: 发行日期.  
   * cover\_url: 封面图片地址 (MinIO).  
4. **Music (音乐)**  
   * id: 主键.  
   * title: 音乐标题.  
   * album\_id: 外键 \-\> Album.id (严格 1:N, 一首音乐仅属一张专辑).  
   * file\_url: 音频文件存储地址 (MinIO).  
   * duration: 时长 (秒).  
   * track\_number: 专辑内音轨号.  
5. **Interaction (交互/评分)**  
   * id: 主键.  
   * user\_id: 外键 \-\> User.id.  
   * music\_id: 外键 \-\> Music.id.  
   * interaction\_type: 枚举 (PLAY, LIKE, SKIP).  
   * weight: 浮点数, 对应的算法权重.  
   * created\_at: 时间戳.

## **5\. 核心功能模块详解 (Functional Modules)**

### **5.1 身份认证模块 (Authentication)**

* **机制**: 采用 JWT (JSON Web Token) 无状态认证。  
* **权限**: 实现基于角色的访问控制 (RBAC)。后端接口需通过依赖注入 (Depends) 校验 current\_user 的 role 字段。

### **5.2 音乐资源管理模块 (Resource Management) \- \[仅限管理员\]**

* **艺术家与专辑管理**: 提供 CRUD 接口。  
* **音乐上传**:  
  1. 管理员上传音频文件。  
  2. 后端验证文件类型 (MP3/FLAC/WAV)。  
  3. 文件异步流式传输至 MinIO Bucket。  
  4. 元数据（包括 MinIO 返回的 URL）写入 PostgreSQL。  
* **约束**: 普通用户无权上传音乐。

### **5.3 播放器与流媒体模块 (Streaming & Player)**

* **播放**: 前端通过 \<audio\> 标签直接请求后端提供的 Presigned URL 或流式响应接口。  
* **功能裁剪**: 明确**不实现**歌词滚动功能。  
* **交互**: 播放器需捕获“播放结束”、“点击红心”等事件，并发送异步请求至后端记录交互数据。

### **5.4 推荐展示模块 (Recommendation View)**

* **每日推荐**: 基于离线计算结果，为用户展示个性化歌单。  
* **冷启动处理**: 对于无历史记录的新用户，默认展示按“热度”排序的音乐列表。

## **6\. 开发与代码规范 (Development Guidelines)**

为确保代码质量符合学术论文标准，必须严格执行以下规范：

### **6.1 注释规范**

* **语言**: 必须使用中文。  
* **内容**: 必须包含 "What" (代码功能) 和 "Why" (设计意图/实现原理)。  
* **示例**:  
  \# 使用 selectinload 策略预加载专辑信息，避免 N+1 查询性能问题  
  \# 相比 joinedload，selectinload 在处理一对多关系时对异步驱动支持更友好  
  stmt \= select(Music).options(selectinload(Music.album))

* **禁令**: 禁止在注释中包含修改日志 (如 "Added by User on 2025-01-01")。

### **6.2 风格规范**

* **专业性**: 严禁在代码、注释、Git Commit Message 中使用任何 Emoji 表情符号。  
* **命名**:  
  * Python: 蛇形命名法 (user\_service.py, get\_user\_by\_id).  
  * TypeScript/Vue: 驼峰命名法 (userProfile.vue, fetchUserData).  
  * SQL 表名: 蛇形复数 (users, albums).

### **6.3 设计模式**

在代码实现中应显式应用并标注软件设计模式：

* **Repository 模式**: 用于隔离业务逻辑层 (Service) 与数据访问层 (Model)。  
* **Dependency Injection (依赖注入)**: 在 FastAPI 中广泛用于数据库会话 (Session) 和当前用户 (CurrentUser) 的注入。  
* **DTO (Data Transfer Object)**: 使用 Pydantic 模型严格区分输入对象 (CreateSchema)、输出对象 (ResponseSchema) 和数据库实体 (Model)。